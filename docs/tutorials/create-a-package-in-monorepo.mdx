---
id: create-a-package-in-monorepo
title: How to Create a Package in Monorepo
sidebar_label: Create a Package in Monorepo
keywords: ["package", "workspaces", "monorepo", "organization of files"]
description: Learn how to share code by creating a package in monorepo
---

:::tip What You’ll Learn
- how to create a new package in monorepo
- how to organize files in monorepo
:::

## Overview
We often need to share code between multiple packages in our project.
:::info
Every Webiny project consists of packages and project applications, you can learn more about them in our [key topics](/docs/key-topics/project-organization/project-applications-and-packages) section.
:::
Every Webiny project is organized as a [monorepo](/docs/key-topics/project-organization/monorepo-organization).
In this tutorial, you will learn how to organize and share code between multiple packages in a monorepo.
Let's get started.

## What We'll Build
In this tutorial, we'll be building a package that contains a simple React component and see how we can share it between multiple packages.
But, you can create a package for backend code as well using similar principles.

Here is the file structure of the package we're about to build:
```
// Some files are omitted for the sake of brevity.

├── api
├── apps
│   ├── admin
│   ├── theme
│   └── website
├── package.json
├── packages
|   |   // This is our new package
│   └── gretting
│       ├── src
│       │   └── index.tsx
│       ├── .babelrc.js
│       ├── README.md
│       ├── package.json
│       ├── tsconfig.build.json
│       └── tsconfig.json
└── yarn.lock
```

## Prerequisites

**A Webiny Project**

This tutorial assumes you have already created a new Webiny project to work on.
We recommend reading our [install Webiny](/docs/tutorials/install-webiny) tutorial which shows you how to do it.

## Create a Package
In this step, we create a new React package.

:::info
The Yarn workspaces aim to make working with monorepos easy.
Learn more about [workspaces](https://yarnpkg.com/features/workspaces) here.
:::

### The Workspaces List
Before we continue, let's quickly cover the workspaces list, located in the `package.json` file in the project root.

The content of the package looks as shown below:

```
(...)
"workspaces": {
    "packages": [
        "packages/*",
        "apps/admin/code",
        "apps/website/code",
        "apps/theme",
        "api/code/fileManager/*",
        "api/code/graphql",
        "api/code/getTime",
        "api/code/headlessCMS",
        "api/code/pageBuilder/*",
        "api/code/prerenderingService/render",
        "api/code/prerenderingService/flush",
        "api/code/prerenderingService/queue/*"
    ]
},
(...)
```

As you can see from the above-mentioned example, a package can be at the root level, for example, `my-package`, or grouped in a folder for example `packages`.
In this tutorial, we use the latter.

### Initialize the Package

Enough with the theory, let’s dive in and initialize the package.

First, create a folder called `packages` where we add our custom package.

:::info
Packages are just regular NPM packages, or in other words, folders with their own package.json
:::

Let's create a folder called `greeting` inside `packages`.
Now that we've created our new folder, let's initialize a new package in it.
For that, we need to create a `package.json` file inside that folder.

You can add it manually or use the following command inside the newly created folder:

```
yarn init
```

Once we execute the above command, we will be presented with a couple of questions as shown below:

<!-- vale off -->

<img
  src={require("./assets/how-to-create-a-package/yarn-init.png").default}
  style={{ marginBottom: 20 }}
  alt="yarn init"
/>

<!-- vale on -->

:::info
You can also run `yarn init -y` to use sensible defaults.
:::

Depending upon your inputs the generated `package.json` file's content may look similar to the following:

```json
{
  "name": "@examples/greeting",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "license": "MIT"
}
```

:::note
The `name` property defined in the package's `package.json` will be used to later import it.
:::

### Create the Package Content

Now that we've initialized a new package, let's start by adding a couple of files.

```json
├── packages
|   |   // This is our new package
│   └── greeting
│       │ // All the source code for the React component will be in this folder.
│       ├── src
│       │   └── index.tsx
│       ├── // A configuration file for babel. More on that later
│       ├── .babelrc.js
│       ├── // A text file about the package
│       ├── README.md
│       ├── // This file is used to give information to npm;
│       ├── // that allows it to identify the package as well as handle the package's dependencies
│       ├── package.json
│       ├── // A configuration file of the TypeScript compiler (tsc)
│       ├── tsconfig.build.json
│       └── // A configuration file of the TypeScript compiler (tsc)
│       └── tsconfig.json
└── yarn.lock

```

### Source Code
First, we write the source code for our example React component.
For that, create a `src` folder inside `packages/greeting` and then add the `index.tsx` file inside it with the following code:

```tsx title="packages/greeting/src/index.tsx"
import React from "react";

const WelcomeMessage = () => {
  return <h1>Welcome to Webiny</h1>
}

export default WelcomeMessage;
```

:::note
Here we're creating a very simple React component. But, you can write whatever logic you need for your project.
:::

Now that we have our desired code in place. We can move to the next step which is adding the required configuration files.

To build our package, we need to add the following configuration files:
- [`package.json`](#packagejson): This file is used to give information to [npm](http://npmjs.com/) that allows it to identify the package as well as handle the package's dependencies.
- [`.babelrc.js`](#babelrcjs): A configuration file for babel.
- [`tsconfig.json`](#tsconfigjson):  A configuration file of the TypeScript compiler (tsc).
- `tsconfig.build.json`  A configuration file of the TypeScript compiler (tsc).

Let's create them one by one.

:::info
You can check out the full list of [tools and libraries](/docs/key-topics/tools-libraries) included in every Webiny.
:::

### `package.json`
Let's start with the `package.json` file.

First, we need to add the following `devDependencies` and `dependencies` as shown below:

```json title="packages/greeting/package.json"
{
  (...)
  "dependencies": {
    "react": "^16.14.0",
    "react-dom": "^16.14.0"
  },
   "devDependencies": {
    "@babel/cli": "^7.5.5",
    "@babel/core": "^7.5.5",
    "@babel/preset-env": "^7.5.5",
    "@babel/preset-react": "^7.0.0",
    "@babel/preset-typescript": "^7.8.3",
    "@svgr/webpack": "^4.3.2",
    "babel-plugin-named-asset-import": "^1.0.0-next.3e165448",
    "rimraf": "^3.0.2",
    "typescript": "^4.1.3"
  },
  (...)
}
```

:::info
You can find out the full example code used in this tutorial in our [repo](https://github.com/webiny/webiny-examples/tree/master/create-package-in-monorepo).
:::

Let's quickly discuss all of them:

#### `dependencies`
The dependencies value is used to specify any other modules that a given module (represented by the package.json) requires to work.

In our case we need the following:
- [`react`](https://www.npmjs.com/package/react): React is a JavaScript library for creating user interfaces..
- [`react-dom`](https://www.npmjs.com/package/react-dom): Serves as the entry point to the DOM and server renderers for React.

#### `devDependencies`
The devDependencies value is used to specific the packages that are only needed for local development and testing.

In our case we need the following:
- [`@babel/cli`](https://www.npmjs.com/package/@babel/cli): Babel command line.
- [`@babel/core`](https://www.npmjs.com/package/@babel/core): Babel compiler core.
- [`@babel/preset-env`](https://www.npmjs.com/package/@babel/preset-env): Babel preset for each environment.
- [`@babel/preset-react`](https://www.npmjs.com/package/@babel/preset-react): Babel preset for all React plugins.
- [`@babel/preset-typescript`](https://www.npmjs.com/package/@babel/preset-typescript): Babel preset for TypeScript.
- [`@svgr/webpack`](https://www.npmjs.com/package/@svgr/webpack): [Webpack](https://webpack.js.org/) loader for SVGR.
- [`babel-plugin-named-asset-import`](https://www.npmjs.com/package/babel-plugin-named-asset-import): Babel plugin for import named exports from non JS/CSS assets.
- [`rimraf`](https://www.npmjs.com/package/rimraf): A deep deletion module for Node.js (like `rm -rf`).
- [`typescript`](https://www.npmjs.com/package/typescript): [TypeScript](https://www.typescriptlang.org/) is a language for application-scale JavaScript.

After that, we add the following scripts inside the `package.json` file:

#### `scripts`
The ["scripts"](https://docs.npmjs.com/cli/v7/using-npm/scripts) property of your package.json file supports a number of built-in scripts
and their preset life cycle events as well as arbitrary scripts.

In our case we need the following:
- [`build`](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/packages/iFrameElement/package.json#L37):
it removes the content of the `dist` folder and compiles the source code via `babel` and runs the `postbuild` command.
- [`watch`](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/packages/iFrameElement/package.json#L38):
it runs the `babel` compiler in `watch` mode, which means the latest changes will compile automatically as source file content changes.
- [`postbuild`](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/packages/iFrameElement/package.json#L39):
as the name suggests, it runs after the completion of the `build` command.
We use it to copy the meta files like `package.json`, `README.md` into the `dist` folder and compile typescript code.

After adding `script` the `package.json` file look as shown below:

```json title="packages/greeting/package.json"
{
  (...)
  "dependencies": {
    "react": "^16.14.0",
    "react-dom": "^16.14.0"
  },
   "devDependencies": {
    "@babel/cli": "^7.5.5",
    "@babel/core": "^7.5.5",
    "@babel/preset-env": "^7.5.5",
    "@babel/preset-react": "^7.0.0",
    "@babel/preset-typescript": "^7.8.3",
    "@svgr/webpack": "^4.3.2",
    "babel-plugin-named-asset-import": "^1.0.0-next.3e165448",
    "rimraf": "^3.0.2",
    "typescript": "^4.1.3"
  },
   "scripts": {
    "build": "rimraf ./dist '*.tsbuildinfo' && babel src -d dist --source-maps --copy-files --extensions \".ts,.tsx\" && yarn postbuild",
    "watch": "babel src -d dist --source-maps --copy-files --extensions \".ts,.tsx\" --watch",
    "postbuild": "cp package.json README.md dist/ && tsc -p tsconfig.build.json"
  }
  (...)
}
```

#### `publishConfig`

And finally, we add `publishConfig` which is a set of configuration values, usually used for package publishing purposes.
But, in our case, this is what enables us to import our newly created package from other packages in different project applications.

:::info
The proper linking of packages is established via the built-in `link-workspaces` command, defined in your root `package.json` file.
<!-- Learn more about linking workspaces in [xyz](#)... -->
:::

After adding `publishConfig` the package.json file look as shown below:
 ```json title="packages/greeting/package.json"
{
  (...)
  "dependencies": {
    "react": "^16.14.0",
    "react-dom": "^16.14.0"
  },
   "devDependencies": {
    "@babel/cli": "^7.5.5",
    "@babel/core": "^7.5.5",
    "@babel/preset-env": "^7.5.5",
    "@babel/preset-react": "^7.0.0",
    "@babel/preset-typescript": "^7.8.3",
    "@svgr/webpack": "^4.3.2",
    "babel-plugin-named-asset-import": "^1.0.0-next.3e165448",
    "rimraf": "^3.0.2",
    "typescript": "^4.1.3"
  },
    "publishConfig": {
    "access": "public",
    "directory": "dist"
  },
   "scripts": {
    "build": "rimraf ./dist '*.tsbuildinfo' && babel src -d dist --source-maps --copy-files --extensions \".ts,.tsx\" && yarn postbuild",
    "watch": "babel src -d dist --source-maps --copy-files --extensions \".ts,.tsx\" --watch",
    "postbuild": "cp package.json LICENSE README.md dist/ && tsc -p tsconfig.build.json"
  }
}
```

:::info
Learn more about [`publishConfig`](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#publishconfig).
:::


### `.babelrc.js`
Now let's take a look at the `.babelrc.js` file which is a configuration file for a tool called [babel](https://babeljs.io/).

:::info
Babel is a JavaScript compiler. We need it because:
- we're writing the `React` code in `JSX` syntax which needs to be converted in `JS`
- we're also using the latest JavaScript features and syntax which are not supported in all browsers, therefore, need to be converted
:::

In the `.babelrc.js` we just export the `.babel.react` configuration file which is defined in the project root.

```js title="packages/greeting/.babelrc.js"
module.exports = require("../../.babel.react");
```

:::info
Every Webiny project comes with a `.babel.react.js` and `.babel.node.js`.
You don't need to know all the configurations.
But, if you're interested feel free to check the full configuration [file](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/.babel.react.js).
:::

### `tsconfig.json`
Every Webiny project prioritizes [TypeScript](https://www.typescriptlang.org/).
But it also needs to be compiled and the `tsconfig.json` file corresponds to the configuration of the TypeScript compiler (tsc).

:::info
Webiny uses TypeScript (v4). Only in a few cases, like for example configuration files, you will encounter pure JavaScript.
:::

Let's take a look at the content of this file:

```json title="packages/greeting/tsconfig.json"
{
  "extends": "../../tsconfig"
}
```

Like the previous file, we're just using the configuration defined in the [project root](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/tsconfig.json) here.

:::info
The `tsconfig.json` file specifies the root files and the compiler options required to compile the project.
Please check out the official docs to [learn more](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#:~:text=a%20tsconfig.json-,Overview,required%20to%20compile%20the%20project.) about it.
:::



### `README.md` (optional)
A README is a text file that introduces and explains a project.
It contains information that is commonly required to understand what the project is about.


## Preparing the Package for Usage
Now that we've created our package and added the required configuration files, it is time to use it.
To do that we need to take the following steps:
- `build` the package
- `link` the package

### Build the Package
To use the package we need to `build` it first.

**"And how do we do that?"** you may ask, remember we added the `build` command under the `scripts` key inside the `package.json` file of the package.
Now it's time we use it.

We can simply `cd` into the package folder which is `packages/greeting` and runs:

```
yarn build
```
And it will work just fine. But, as your project grows and you add more packages. It becomes a chore to run the same command across multiple packages.

Webiny CLI provides the workspaces run (or ws run for short) command that enables you to run single command across multiple workspaces at once.
The common use case where this might be needed is local development, where you want to watch for code changes on multiple packages, and rebuild them accordingly.

:::info
We recommend reading the [Working With Workspaces](http://docs.webiny.com/docs/how-to-guides/webiny-cli/working-with-workspaces) article to learn more about workspaces.
:::

For example, to establish a watch session across multiple packages, located in a specific folder, you can run the following command:

```
yarn webiny ws run watch --folder packages
```

On the other hand, if you wanted to build all of the packages, again, located in a specific folder, you can run:
```
yarn webiny ws run build --folder packages
```

:::note
The `ws run` command executes the command in question for every workspace present in the folder.
In our case, `packages/greeting`.
:::

### Install the Package
Now that we've built the package. It's time to install and link the package.
Run the following command:
```
yarn install
```
By simply executing the above-mentioned command. The package is installed and linked via workspaces.
Because using [`postinstall`](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/package.json#L64) hook we also run [`link-workspaces`](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/scripts/linkWorkspaces.js) script.

### Using the Package in Apps

After completing all these steps you can now simply import and use it as a regular npm package.

```ts
import WelcomeMessage from "@examples/greeting";
```

## Conclusion

Congratulations!! 🎉🥳

You've successfully created a new package in monorepo.
Monorepo organization makes it possible to structure different logical pieces of your project as multiple packages.

You can also check out a similar code example in our [repo](https://github.com/webiny/webiny-examples/tree/master/create-package-in-monorepo).
If you have further questions, feel free to [ask](https://www.webiny.com/slack) for additional help.
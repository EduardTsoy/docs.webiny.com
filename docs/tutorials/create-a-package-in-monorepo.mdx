---
id: create-a-package-in-monorepo
title: How to Create a Package in Monorepo
sidebar_label: Create a Package in Monorepo
keywords: ["package", "workspaces", "monorepo", "organization of files"]
description: Learn how to share code by creating a package in monorepo
---

:::tip What You’ll Learn
- how to create a new package in monorepo
- how to organize files in monorepo
:::

## Overview
We often need to share code between multiple packages in our project.
:::info
Every Webiny project consists of packages and project applications, you can learn more about them in our [key topics](/docs/key-topics/project-organization/project-applications-and-packages).
:::
Every Webiny project is organized as a [monorepo](/docs/key-topics/project-organization/monorepo-organization).
In this tutorial, you will learn how to organize and share code between multiple packages in a monorepo.
Let's get started.

## What We'll Build
In this tutorial, we'll be building a package that contains a simple React component and see how we can share it between multiple packages.
But, you can create a package for backend code as well using similar principles.

Here is the file structure of the package we're about to build:
```
// Some files are omitted for the sake of brevity.

├── api
├── apps
│   ├── admin
│   ├── theme
│   └── website
├── package.json
├── packages
|   |   // This is our new package
│   └── gretting
│       ├── src
│       │   └── index.tsx
│       ├── .babelrc.js
│       ├── README.md
│       ├── package.json
│       ├── tsconfig.build.json
│       └── tsconfig.json
└── yarn.lock
```

## Prerequisites

**A Webiny Project**

This tutorial assumes you have already created a new Webiny project to work on.
We recommend reading our [install Webiny](/docs/tutorials/install-webiny) tutorial which shows you how to do it.

## Create a Package
In this step, we create a new React package and add it to the workspaces list.

:::info
The Yarn workspaces aim to make working with monorepos easy.
Learn more about [workspaces](https://yarnpkg.com/features/workspaces) here.
:::

### The Workspaces List
Before we continue, let's quickly cover the workspaces list, located in the `package.json` file in your project root.

The content of the package looks as shown below: 

```
(...)
"workspaces": {
    "packages": [
        "packages/*",
        "apps/admin/code",
        "apps/website/code",
        "apps/theme",
        "api/code/fileManager/*",
        "api/code/graphql",
        "api/code/getTime",
        "api/code/headlessCMS",
        "api/code/pageBuilder/*",
        "api/code/prerenderingService/render",
        "api/code/prerenderingService/flush",
        "api/code/prerenderingService/queue/*"
    ]
},
(...)
```

As you can see from the above-mentioned example, a package can be at the root level for example, `my-package` or grouped in a folder for example `packages`.
In this tutorial, we use the latter.

Enough with the theory, let’s dig in.

First, create a folder called `packages` where we add our custom package.

:::info
Packages are just regular NPM packages, or in other words, folders with their own package.json
:::

Let's create a folder called `greeting` inside `packages`.
Now that we've created our new folder, let's initialize a new package in it.
For that we need to create a `package.json` file inside that folder.

You can add it manually or use the following command inside the newly created folder:

```
yarn init
```

Once we execute the above command, we will be presented with a couple of questions as shown below:

<!-- vale off -->

<img
  src={require("./assets/how-to-create-a-package/yarn-init.png").default}
  style={{ marginBottom: 20 }}
  alt="yarn init"
/>

<!-- vale on -->

:::info
You can also run `yarn init -y` to use sensible defaults.
:::

Depending upon your inputs the generated `package.json` file's content may look similar to the following:

```json
{
  "name": "@examples/greeting",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "license": "MIT"
}
```

:::note
The `name` property defined in the package's `package.json` will be used to later import it.
:::

Now that we've initialized a new package, let's start by adding a couple of files.

```
├── packages
|   |   // This is our new package
│   └── gretting
│       ├── src
│       │   └── index.tsx
│       ├── .babelrc.js
│       ├── README.md
│       ├── package.json
│       ├── tsconfig.build.json
│       └── tsconfig.json
└── yarn.lock

```

First, we are going to add the source code.
For that create a `src` folder inside `packages/greeting` and then add the `index.tsx` file inside it with the following code:

```tsx title="packages/greeting/src/index.tsx"
import React from "react";

const WelcomeMessage = () => {
  return <h1>Welcome to Webiny</h1>
}

export default WelcomeMessage;
```

:::note
Here we're creating a very simple React component. But, you can write whatever logic you need for your project.
:::

Now that we have our desired code in place. We can move to the next step which is adding the required configuration files.

To build our package, we need to add the following configuration files:
- `package.json`
- `.babelrc.js`
- `tsconfig.json`
- `tsconfig.build.json`

Let's create them one by one.

### `package.json`
Let's start with the `package.json` file.
First, we need to add the following `devDependencies`:

```json title="packages/greeting/package.json"
{
  (...)
   "devDependencies": {
    "@babel/cli": "^7.5.5",
    "@babel/core": "^7.5.5",
    "@babel/preset-env": "^7.5.5",
    "@babel/preset-react": "^7.0.0",
    "@babel/preset-typescript": "^7.8.3",
    "@svgr/webpack": "^4.3.2",
    "babel-plugin-named-asset-import": "^1.0.0-next.3e165448",
    "rimraf": "^3.0.2",
    "typescript": "^4.1.3"
  },
  (...)
}
```

Then add `react` and `react-dom` to `dependencies` as shown below:

```json title="packages/greeting/package.json"
{
  (...)
  "dependencies": {
    "react": "^16.14.0",
    "react-dom": "^16.14.0"
  },
   "devDependencies": {
    "@babel/cli": "^7.5.5",
    "@babel/core": "^7.5.5",
    "@babel/preset-env": "^7.5.5",
    "@babel/preset-react": "^7.0.0",
    "@babel/preset-typescript": "^7.8.3",
    "@svgr/webpack": "^4.3.2",
    "babel-plugin-named-asset-import": "^1.0.0-next.3e165448",
    "rimraf": "^3.0.2",
    "typescript": "^4.1.3"
  },
  (...)
}
```

After that, we add the following scripts inside the `package.json` file:
- `build`
- `watch`
- `postbuild`

```json title="packages/greeting/package.json"
{
  (...)
  "dependencies": {
    "react": "^16.14.0",
    "react-dom": "^16.14.0"
  },
   "devDependencies": {
    "@babel/cli": "^7.5.5",
    "@babel/core": "^7.5.5",
    "@babel/preset-env": "^7.5.5",
    "@babel/preset-react": "^7.0.0",
    "@babel/preset-typescript": "^7.8.3",
    "@svgr/webpack": "^4.3.2",
    "babel-plugin-named-asset-import": "^1.0.0-next.3e165448",
    "rimraf": "^3.0.2",
    "typescript": "^4.1.3"
  },
   "scripts": {
    "build": "rimraf ./dist '*.tsbuildinfo' && babel src -d dist --source-maps --copy-files --extensions \".ts,.tsx\" && yarn postbuild",
    "watch": "babel src -d dist --source-maps --copy-files --extensions \".ts,.tsx\" --watch",
    "postbuild": "cp package.json LICENSE README.md dist/ && tsc -p tsconfig.build.json"
  }
  (...)
}
```

And finally, we add `publishConfig` which is a set of configuration values that are being used at publish-time.

In other words, when you run the `npm publish` command to publish a package to the registry so that it can be installed by name.

 ```json title="packages/greeting/package.json"
{
  (...)
  "dependencies": {
    "react": "^16.14.0",
    "react-dom": "^16.14.0"
  },
   "devDependencies": {
    "@babel/cli": "^7.5.5",
    "@babel/core": "^7.5.5",
    "@babel/preset-env": "^7.5.5",
    "@babel/preset-react": "^7.0.0",
    "@babel/preset-typescript": "^7.8.3",
    "@svgr/webpack": "^4.3.2",
    "babel-plugin-named-asset-import": "^1.0.0-next.3e165448",
    "rimraf": "^3.0.2",
    "typescript": "^4.1.3"
  },
    "publishConfig": {
    "access": "public",
    "directory": "dist"
  },
   "scripts": {
    "build": "rimraf ./dist '*.tsbuildinfo' && babel src -d dist --source-maps --copy-files --extensions \".ts,.tsx\" && yarn postbuild",
    "watch": "babel src -d dist --source-maps --copy-files --extensions \".ts,.tsx\" --watch",
    "postbuild": "cp package.json LICENSE README.md dist/ && tsc -p tsconfig.build.json"
  }
}
```

:::info
Learn more about [`publishConfig`](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#publishconfig).
:::


### `.babelrc.js`
Now let's take a look at the `.babelrc.js` file which is a configuration file for a tool called [babel](https://babeljs.io/).

:::info
Babel is a JavaScript compiler. We need it because:
- we're writing the `React` code in `JSX` syntax which need to be converted in `JS`
- we're also using the latest JavaScript features and syntax which are not supported in all browsers, therefore, need to be converted
:::

In the `.babelrc.js` we just export the `.babel.react` configuration file which is defined in the project root.

```js title="packages/greeting/.babelrc.js"
module.exports = require("../../.babel.react");
```

:::info
Every Webiny project comes with a `.babel.react.js` and `.babel.node.js`.
You don't need to know all the configurations.
But, if you're interested feel free to check the full configuration [file](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/.babel.react.js).
:::

### `tsconfig.json`
Every Webiny project prioritizes [TypeScript](https://www.typescriptlang.org/).
But it also needs to be complied and the `tsconfig` file corresponds to the configuration of the TypeScript compiler (tsc).

Let's take a look at the content of this file:

```json title="packages/greeting/tsconfig.json"
{
  "extends": "../../tsconfig"
}
```

Like the previous file, we're just using the configuration defined in the [project root](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/tsconfig.json) here.

:::info
The `tsconfig.json` file specifies the root files and the compiler options required to compile the project.
[Learn more](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#:~:text=a%20tsconfig.json-,Overview,required%20to%20compile%20the%20project.)
:::



### `README.md` (optional)
A README is a text file that introduces and explains a project.
It contains information that is commonly required to understand what the project is about.


## Preparing the Package for Usage
Now that we've created our package and added the required configuration files. It's time to use it.
To do that we need to follow the following steps:
- build the package
- link the package

### Build the Package
To use the package we need to `build` it first.

**"And how do we do that?"** you may ask:

Remember we added the `build` command under the `scripts` key inside the `package.json` file of the package.
Now it's time we use it. We can simply `cd` into the package folder that is `packages/greeting` and run:

```
yarn build
```
And it will work just fine. But, as your project grows and you add more packages. It becomes a chore to run the same command across multiple packages.

Webiny CLI provides the workspaces run (or ws run for short) command that enables you to run single command across multiple workspaces at once.
The common use case where this might be needed is local development, where you want to watch for code changes on multiple packages, and rebuild them accordingly.

:::info
We recommend reading the [Working With Workspaces](http://docs.webiny.com/docs/how-to-guides/webiny-cli/working-with-workspaces)
article to learn more about workspaces.
:::

We can use it for building the package and/or running a watch session while developing the code (so that the latest changes get rebuild).

For example, to establish a watch session across multiple packages, located in a specific folder, you can run the following command:

```
yarn webiny ws run watch --folder packages
```

On the other hand, if you wanted to build all of the packages, again, located in a specific folder, you can run:
```
yarn webiny ws run build --folder packages
```

:::note
The `ws run` command executes the command in question for every workspace present in the folder.
In our case, `packages/greeting`.
:::

### Install the Package
Now that we've built the package. It's time to install and link the package.
Run the following command:
```
yarn install
```
By simply executing the above-mentioned command. The package is installed and linked via workspaces.
Because using [`postinstall`](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/package.json#L64) hook we also run [`link-workspaces`](https://github.com/webiny/webiny-examples/blob/master/iframe-page-element/scripts/linkWorkspaces.js) script.

### Using the Package in Apps

After completing all these steps you can now simply import and use it as a regular npm package.

```ts
import WelcomeMessage from "@examples/greeting";
```

## Conclusion

Congratulations!! 🎉🥳

You've successfully created a custom package in monorepo.
Monorepo organization makes it possible to structure different logical pieces of your project as multiple packages.

You can also check out a similar code example in our [repo](https://github.com/webiny/webiny-examples/tree/master/iframe-page-element).
If you have further questions, feel free to [ask](https://www.webiny.com/slack) for additional help.